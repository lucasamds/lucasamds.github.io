---
layout: post
title: Quantização vetorial com k-means
mathjax: true
---


<div class="message">
  Último post da série de processamento digital de imagens. Hoje vamos dar uma olhada na quantização vetorial utilizando o <em>k-means</em>.
</div>

Dizemos que uma quantização foi feita quando conseguimos mapear os dados de um conjunto grande em um conjunto de tamanho menor, como aqui em nossos experimentos trabalhamos com vetores, ao dividir os dados em grupos menores, ou seja, vetores menores, podemos dizer que foi feita uma quantização vetorial.

## k-means

Existem vários algoritmos que realização a quantização vetorial, neste experimento vamos utilizar o método k-means. O algoritmo k-means vai separar os dados em células que são determinadas por um centro, de forma que, todos os pontos que possuírem uma distância para um determinado centro menor do que para os demais centros vão pertencer a mesma célula. O método funciona de acordo com a seguinte sequência.

1. Escolher um número de classes $$ k $$ para os vetores $$ x_{i} $$ de $$ N $$ amostras, com $$ i = 1, 2, ..., N $$.
2. Escolher as aproximações iniciais para os centros das classes $$ m_{1}, m_{2}, ..., m_{k} $$.
3. Classificar cada amostra com relação ao seu centro mais próximo, essa categorização vai ser feita com base em um classificador de distância mínima.
4. Com base no resultado do passo 3, recalcular as médias de cada grupo.
5. Se a variação entre as médias seja muito baixa, considera-se que elas são consistentes e o algoritmo é encerrado. Caso a diferença de média ainda seja considerada relevante, é feito um novo cálculo para os centros e em seguida uma reclassificação dos dados.

Uma característica do algoritmo k-means é que ele vai gerar resultados diferentes para cada execução, devido a isso, é uma prática comum realizar algumas execuções do k-means e escolher a execução que gerou o melhor resultado. Neste experimento vamos aplicar o método em uma imagem colorida e comparar alguns resultados obtidos.


<a id="listagem1"></a>
##### Listagem 1. kmeans.py
{% highlight python %}

import numpy as np
import cv2 as cv
import sys

img = cv.imread('imagens/kmeans2.jpg')
if img is None:
    sys.exit('Imagem não encontrada')

height = img.shape[0]
width = img.shape[1]
nClusters = 16
nClusters_max = 50
nRodadas = 1
nRodadas_max = 10
samples = np.empty((height*width, 3), dtype=np.float32)
rotulos = np.empty(samples.shape, dtype=np.float32)


for y in range(height):
    for x in range(width):
        for z in range(3):
            samples[y+x*height, z] = img[y, x, z]

criteria = (cv.TERM_CRITERIA_MAX_ITER|cv.TERM_CRITERIA_EPS, 1000, 0.0001)


def fazkmeans():
    global rotulos
    rotulada = np.empty(img.shape, dtype=img.dtype)
    _,rotulos, centros = cv.kmeans(samples, nClusters, rotulos, criteria, nRodadas, cv.KMEANS_PP_CENTERS)
    for y in range(height):
        for x in range(width):
            indice = rotulos[y+x*height, 0]
            rotulada[y, x, 0] = np.uint8(centros[indice, 0])
            rotulada[y, x, 1] = np.uint8(centros[indice, 1])
            rotulada[y, x, 2] = np.uint8(centros[indice, 2])
    cv.imshow('Clustered image', rotulada)


def mudouncluster(x):
    global nClusters
    nClusters = x
    fazkmeans()


def mudounrodadas(x):
    global nRodadas
    nRodadas = x
    fazkmeans()

cv.namedWindow('Clustered image', cv.WINDOW_AUTOSIZE)
cv.createTrackbar('nClusters', 'Clustered image', nClusters, nClusters_max, mudouncluster)
cv.createTrackbar('nRodadas', 'Clustered image', nRodadas, nRodadas_max, mudounrodadas)
fazkmeans()
cv.waitKey()

{% endhighlight %}

## Descrição do programa kmeans.py

{% highlight python %}
samples = np.empty((height*width, 3), dtype=np.float32)
rotulos = np.empty(samples.shape, dtype=np.float32)
{% endhighlight %}


